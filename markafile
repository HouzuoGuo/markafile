#!/usr/bin/env python3
import os
import re
import sys
import signal
import sqlite3

from os import walk
from os.path import isfile, isdir, abspath, exists
from os.path import join as path_join
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from textwrap import dedent

DESC = '''
NAME
    markafile - file tagging for *nix operating systems

DESCRIPTION
    markafile is a file tagging utility for applying multiple tags to files in
    file system, and later those files may be searched by a search expression.

    markafile uses SQLite database to store tags and tagged files, thus no
    write access to the tagged files is required. However markafile will
    require read/execute permission on tagged directories and read permission
    on tagged files.

    Tag name is case in-sensitve and may not contain space(s). Any number of
    tags may be applied to any file.

    Should any error occur, markafile will exit with status 1 and print error
    details to STDERR.

SEARCH EXPRESSION LANGUAGE
    Search expression is a mini-language consists of tag names, keywords and
    parenthesis. The expression is translated into SQL query for execution.

    TAG NAMES
        Case in-sensitive names which were used to tag files
    KEYWORDS
        Logical operators "and", "or", "not"
    PARANTHESIS
        To elevate precedence of their enclosed expression

    See also EXAMPLES.

EXAMPLES
    Apply multiple tags to files
    markafile tag "cron script" /etc/cron.daily/* /etc/cron.hourly/*

    Tag directory files (including sub-directories)
    markafile tag "conf" /etc -r

    Remove tags
    markafile untag "conf" /etc -r

    Show all tagged files and tags
    markafile find "*" /etc/ -r




BUGS
    Although search results are guaranteed to be valid, however moved/deleted
    files are not tracked automatically - their associated tags will remain in
    database and will be automatically cleared once the tags are searched for.

AUTHOR
    Howard Guo <guohouzuo@gmail.com>

REPORTING BUGS
    Please contact the author by Email for bug report and feedback.

COPYRIGHT

'''

SETUP = '''CREATE TABLE IF NOT EXISTS TAG (
             ID INTEGER PRIMARY KEY AUTOINCREMENT,
             PATH TEXT NOT NULL,
             TAG TEXT COLLATE NOCASE NOT NULL
           );

           CREATE INDEX IF NOT EXISTS TAG_PATH ON TAG (PATH);
           CREATE INDEX IF NOT EXISTS TAG_TAG ON TAG (TAG COLlATE NOCASE);
           CREATE INDEX IF NOT EXISTS TAG_BOTH ON TAG
           (PATH, TAG COLLATE NOCASE);'''

args, db = None, None


def debug(msg):
    if args and args.debug:
        sys.stderr.write(msg + '\n')


def panic(msg):
    sys.stderr.write('ERROR: {0}\n'.format(msg))
    sys.exit(1)


def connect():
    global args, db
    if not (args or args.db or args.db.strip()):
        panic('Database path may not be blank')

    db = sqlite3.connect(args.db)
    debug('Connected to "{0}"'.format(args.db))


def disconnect():
    global db
    if db:
        db.commit()
        db.close()
        debug('Disconnected')


def setup():
    cursor = db.cursor()
    cursor.executescript(SETUP)
    disconnect()
    connect()
    debug('Database setup completed')


def parsepath():
    global args
    files = []
    for path in args.files:
        path = abspath(path)
        if isfile(path):
            files.append(path)
        elif isdir(path):
            if args.recursive:
                for root, _, dir_files in walk(path):
                    files += [path_join(root, single_file)
                              for single_file in dir_files]
            else:
                files += [path_join(path, x) for x in next(walk(path))[2]]
    return files


def tag():
    global db, args
    if not args.tags:
        return

    new_tags = []
    cursor = db.cursor()
    for tag in args.tags.split():
        for path in parsepath():
            cursor.execute('SELECT COUNT(*) FROM TAG ' +
                           'WHERE PATH = ? AND TAG = ?', (path, tag))
            if cursor.fetchone()[0]:
                debug('File "{0}" already has tag "{1}"'.format(path, tag))
            else:
                new_tags.append((path, tag))
                debug('Add tag "{0}" to file "{1}"'.format(tag, path))
    cursor = db.cursor()
    cursor.executemany('INSERT INTO TAG(PATH, TAG) VALUES (?, ?)',
                       new_tags)
    db.commit()


def untag():
    global db, args
    if not (args and args.tags):
        return

    cursor = db.cursor()
    cursor.executemany('DELETE FROM TAG WHERE PATH = ? AND TAG = ?',
                       [(path, tag)
                        for path in parsepath()
                        for tag in args.tags.split()])
    db.commit()


def find():
    global db, args
    if not (args and args.tags):
        return

    cursor = db.cursor()
    if args.tags == '*':
        for path in parsepath():
            cursor.execute('SELECT TAG FROM TAG WHERE PATH = ?', (path,))
            rows = cursor.fetchall()
            if rows:
                print(path + ': ' + ' '.join([row[0] for row in rows]))
    else:
        keywords = set(['and', 'not', 'or', '(', ')'])
        parameters = []

        # Split search expression into operators and tag names
        query_parts = []
        for part in [part.strip() for part in re.split('[()\s]+', args.tags)]:
            if not part:
                continue
            if part in keywords:
                query_parts.append(part)
            else:
                query_parts.append('? IN (SELECT T2.TAG FROM TAG T2 ' +
                                   'WHERE T2.PATH = T1.PATH)')
                parameters.append(part)

        paths = parsepath()

        # Avoid too many parameters
        for i in range(0, len(paths), 500):
            files = paths[i:i + 500]
            path_parts = ['?' for _ in paths]

            # Construct the query
            query = 'SELECT T1.PATH, T1.TAG FROM TAG T1 '
            query += 'WHERE (' + ' '.join(query_parts) + ') '
            query += 'AND PATH IN (' + ', '.join(path_parts) + ')'
            debug('Query: ' + query)
            debug('Parameters: ' + str(parameters))

            all_params = parameters
            all_params += files

            path_tags = {}
            cursor.execute(query, all_params)

            # Make path VS tags mapping
            for path, tag in cursor.fetchall():
                if exists(path):
                    try:
                        path_tags[path].append(tag)
                    except KeyError:
                        path_tags[path] = [tag]
                else:
                    cursor.execute('DELETE FROM TAG WHERE PATH = ?', (path,))

            for path in path_tags:
                print(path + ': ' + ' '.join(path_tags[path]))

ACTIONS = {'tag': tag, 'untag': untag, 'find': find}

if __name__ == '__main__':
    parser = ArgumentParser(description=dedent(DESC),
                            formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--db', help='user specified database path')
    parser.add_argument('-r', action='store_true', dest='recursive',
                        help='tag/untag including sub-directories')
    parser.add_argument('--debug', action='store_true', dest='debug',
                        help='print debug messages to stderr')
    parser.add_argument('action', help='tag/untag/find/daemon')
    parser.add_argument('tags', nargs='?',
                        help='tags or search expression (in quotes)')
    parser.add_argument('files', help='list of files', nargs='*')
    args = parser.parse_args()

    # Default database is a hidden file in user's home directory
    if not args.db:
        args.db = os.path.expanduser('~/.markafile.sqlite3')
    signal.signal(signal.SIGTERM, disconnect)

    try:
        if args.action in ACTIONS:
            connect()
            setup()  # Prepare tag database
            ACTIONS[args.action]()  # Execute specified action
            disconnect()
            sys.exit(0)
        else:
            parser.print_help()
            sys.exit(1)
    except sqlite3.Error as err:
        panic('Database error: ' + str(err))
