#!/usr/bin/python3
import os
import sys
import signal
import sqlite3

from os import walk, sep
from os.path import isfile, isdir, abspath
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from textwrap import dedent

DESC = '''
markafile - all-in-one solution for file tagging
'''

SETUP = ['''CREATE TABLE IF NOT EXISTS TAG (
             ID INTEGER PRIMARY KEY AUTOINCREMENT,
             DIR TEXT NOT NULL,
             PATH TEXT NOT NULL,
             TAG TEXT NOT NULL
           )''',
           '''CREATE TABLE IF NOT EXISTS WATCH (
             ID INTEGER PRIMARY KEY AUTOINCREMENT,
             DIR TEXT NOT NULL
           )''',
           'CREATE INDEX IF NOT EXISTS TAG_DIR ON TAG (DIR)',
           'CREATE INDEX IF NOT EXISTS TAG_TAG ON TAG (TAG)',
           'CREATE INDEX IF NOT EXISTS TAG_PATH ON TAG (PATH)',
           'CREATE INDEX IF NOT EXISTS WATCH_DIR ON WATCH (DIR)']

args, db = None, None

def debug(msg):
    if args and args.debug:
        sys.stderr.write(msg + '\n')


def panic(msg):
    sys.stderr.write('ERROR: {0}\n'.format(msg))
    sys.exit(1)


def connect():
    global args, db
    if not (args or args.db or args.db.strip()):
        sys.stderr.write('Database path may not be blank')
        sys.exit(1)
    try:
        db = sqlite3.connect(args.db)
        debug('Connected to "{0}"'.format(args.db))
    except sqlite3.Error as err:
        panic('Connection error "{0}"'.format(str(err)))


def disconnect():
    global db
    try:
        if db:
            db.commit()
            db.close()
            debug('Disconnected')
    except sqlite3.Error as err:
        panic('Cannot close connection, error "{0}"'.format(str(err)))


def setup():
    try:
        for statement in SETUP:
            cursor = db.cursor()
            cursor.execute(statement)
        disconnect()
        connect()
        debug('Database setup completed')
    except sqlite3.Error as err:
        panic('Cannot setup database, error "{0}"'.format(str(err)))


def parsefiles():
    global args
    files = []
    for path in args.files:
        path = abspath(path)
        if isfile(path):
            files.append(path)
        elif isdir(path):
            if args.recursive:
                for entry in walk(path):
                    files.extend([path + sep + x for x in entry[3]])
            else:
                files.extend([path + sep + x for x in next(walk(path))[2]])


def tag():
    global db, args
    if not args.tags:
        return
    for tag in args.tags:
        for path in parsefiles():
            pass

def untag():
    global db, args


def find():
    global db, args


def daemon():
    global db

ACTIONS = {'tag': tag, 'untag': untag, 'find': find, 'daemon': daemon}

if __name__ == '__main__':
    parser = ArgumentParser(description=dedent(DESC),
                            formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--db', help='user specified database path')
    parser.add_argument('--debug', action='store_true', dest='debug',
                        help='print debug messages to stderr')
    parser.add_argument('action', help='tag/untag/find/daemon')
    parser.add_argument('tags', nargs='?',
                        help='tags or search expression (in quotes)')
    parser.add_argument('files', help='list of files', nargs='*')
    args = parser.parse_args()

    # Default database is a hidden file in user's home directory
    if not args.db:
        args.db = os.path.expanduser('~/.markafile.sqlite3')
    signal.signal(signal.SIGTERM, disconnect)

    # Execute specified action
    if args.action in ACTIONS:
        connect()

        # Prepare tag database
        setup()
        ACTIONS[args.action]()
        disconnect()
        sys.exit(0)

    parser.print_help()
    sys.exit(1)
